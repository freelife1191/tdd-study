# 테스트 주도 개발 시작하기

---

## To Do
- [X] Chapter 1. TDD 개발 준비
- [X] Chapter 2. TDD 시작
- [ ] Chapter 3. 테스트 코드 작성 순서
- [ ] Chapter 4. TDD • 기능 명세 • 설계
- [ ] Chapter 5. Junit 5 기초
- [ ] Chapter 6. 테스트 코드의 구성
- [ ] Chapter 7. 대역
- [ ] Chapter 8. 테스트 가능한 설계
- [ ] Chapter 9. 테스트 범위와 종류
- [ ] Chapter 10. 테스트 코드와 유지 보수
- [ ] Chapter 11. 마치며
- [ ] 부록 A. Junit 5 추가 내용
- [ ] 부록 B. Junit 4 기초
- [ ] 부록 C. Mockito 기초 사용법
- [ ] 부록 D. AssertJ 소개

---

## Chapter 2. TDD 시작

암호 강도 측정 기능을 TDD로 구현

1. 모든 규칙을 충족하는 암호 강도는 '강함'
2. 길이만 8글자 미만이고 나머지 규칙은 충족하는 암호의 강도는 '보통'
3. 숫자를 포함하지 않고 나머지 규칙은 충족하는 암호의 강도는 '보통'
4. 값이 없는 암호의 강도는 '유효하지 않음'
5. 대문자를 포함하지 않고 나머지 규칙은 충족하는 경우
6. 길이가 8글자 이상인 규칙만 충족하는 경우
7. 숫자 포함 규칙만 충족하는 경우
8. 대문자 포함 규칙만 충족하는 경우
9. 아무 규칙도 충족하지 않는 경우

### TDD 흐름
TDD는 테스트를 먼저 작성하고 테스트 통과시킬 만큼 코드를 작성하고 리팩토링으로 마무리 하는 과정을 반복한다

> 레드-그린-리팩터
TDD 사이클을 레드(Red)-그린(Green)-리팩터(Refactor)로 부르기도 함  
여기서 레드는 실패를 의미. 레드는 테스트 코드가 실패하면 빨간색을 이용해서 실패한 테스트를 보여주는 데서 비롯함.  
비슷하게 그린은 성공한 테스트를 의미. 즉 코드를 구현해서 실패하는 테스트를 통과시키는 것을 뜻함.  
마지막으로 리팩터는 이름 그대로 리팩토링 과정을 의미함.

### 테스트가 개발을 주도
테스트 코드를 먼저 작성하면 테스트가 개발을 주도하게 된다  

- 가장 먼저 통과해야할 테스트 작성
- 테스트를 작성하는 과정에서 구현을 생각하지 않음
- 해당 기능이 올바르게 동작하는지 검증할 수 있는 테스트 코드 작성
- 테스트 추가 후 테스트를 통과시킬 만큼 기능을 구현
- 아직 추가하지 않은 테스트를 고려해서 구현하지 않음
- 테스트 코드를 만들면 다음 개발 범위가 정해짐
- 테스트 코드가 추가되면서 검증하는 범위가 넓어질수록 구현도 점점 완성됨

### 지속적인 코드 정리
구현을 완료한 뒤에는 리팩토링을 진행

- 리팩토링할 대상이 눈에 들어오면 리팩토링을 진행해서 코드를 정리
- 당장 리팩토링할 대상이나 어떻게 리팩토링해야 할지 생각나지 않으면 다음 테스트 진행
- 테스트 코드 자체도 리팩토링 대상
- TDD는 개발 과정에서 지속적으로 크드를 정리하므로 코드 품질이 급격히 나빠지지 않게 막아주는 효과가 있음
- 이는 향후 유지보수 비용을 낮추는데 기여함

### 빠른 피드백
TDD가 주는 이점은 코드 수정에 대햔 피드백이 빠르다는 점이다

- 새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인할 수 있음
- 이는 잘못된 코드가 배포되는 것을 방지함

---

## Chapter 3. 테스트 코드 작성 순서

### 초반에 복잡한 테스트부터 시작하면 안 되는 이유
만약 초반 부터 다양한 조합을 검사하는 복잡한 상황을 테스트로 추가하면 해당 테스트를 통과 시키기 위해 한 번에 구현해야 할 코드가 많아진다

한 번에 완벽한 코드를 만들면 좋겠지만, 모두가 수퍼 개발자인 것은 아니다  
보통의 개발자는 한 번에 많은 코드를 만들다 보면 나도 모르게 버그를 만들고 나중에 버그를 잡기 위해 많은 시간을 허비하게 된다  
당연히 테스트 통과 시간도 길어진다  
그뿐만 아니라 코드 작성 시간이 길어지면 집중력도 떨어져서 흐름이 자주 끊기게 된다

### 구현하기 쉬운 테스트부터 시작하기
가장 구현하기 쉬운 경우부터 시작하면 빠르게 테스트를 통과시킬 수 있다  
보통 수 분에서 십여 분 이내에 구현을 완료해서 테스트를 통과시킬 수 있을 만큼 쉬운 것을 선택한다  
이를 통해 점진적으로 구현을 완성해 나갈 수 있다

한 번에 구현하는 시간이 짧아지면 디버깅할 때에 유리하다

### 예외 상황을 먼저 테스트해야 하는 이유
다양한 예외 상황은 복잡한 if-else 블록을 동반할 때가 많다  
예외 상황을 전혀 고려하지 않은 코드에 예외 상황을 반영하려면 코드의 구조를 뒤집거나 코드 중간에 예외 상황을 처리하기 위해 조건문을 중복해서 추가하는 일이 벌어진다  
이는 코드를 복잡하게 만들어 버그 발생 가능성을 높인다  

TDD를 하는 동안 예외 상황을 찾고 테스트에 반영하면 예외 상황을 처리하지 않아 발생하는 버그도 줄여준다  
예외 상황을 찾고 테스트하면 이런 문제가 발생할 가능성을 사전에 낮출 수 있다  

### 완급 조절
처음 TDD로 구현할 때 어려운 것 중 하나는 한 번에 얼마만큼의 코드를 작성할 것인가이다  
TDD를 처음 접할 때는 다음 단계에 따라 TDD를 익혀보자  

1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화

TDD가 익숙해지면 상황에 따라 구현 속도를 조절할 수 있게 된다  
단순 덧셈이나 길이 비교와 같은 명백한 구현은 상수를 사용하지 않고 바로 구현하고 한 번에 구현을 시도했는데 잘 안되면 한발 물러서서 천천히 단계를 밟아 나가면 된다  

### 지속적인 리팩토링
테스트를 통과한 뒤에는 리팩토링을 진행한다  
매번 리팩토링을 진행해야 하는 것은 아니지만 적당한 후보가 보이면 리팩토링을 진행한다  
코드의 중복은 대표적인 리팩토링 대상이다  
코드가 길어지면 메서드 추출과 같은 기법을 사용해서 메서드 이름으로 코드의 의미를 표현할 수 있다  

TDD를 진행하는 과정에서 지속적으로 리팩토링을 진행하면 코드 가독성이 높아진다  
이는 코드 변경의 어려움을 줄여주어 향후 유지보수에 도움이 된다

> 일단 동작하는 코드를 만드는 능력은 중요하다. 코드가 동작하지 않으면 아무것도 소용없기 때문이다.  
> 하지만 소프트웨어의 생존 시간이 길어질수록 소프트웨어를 지속적으로 개선해야 한다.  
> 즉 코드를 변경해야 한다. 코드 변경이 어려우면 변화하는 요구를 제때 반영할 수 없게 되며 이는 소프트웨어의 생존과 직결된다.  
> 따라서 코드를 잘 변경할 수 있는 능력 또한 매우 중요하다  
> 
> 코드를 잘 변경하려면 변경하기 쉬운 구조를 가져야 하는데 이를 위한 것이 바로 리팩토링이다  
> 리팩토링을 통해 이해하고 변경하기 쉽게 코드를 개선함으로써 변화하는 요구 사항을 적은 비용으로 반영할 수 있다  
> 이는 소프트웨어의 생존 시간을 늘려준다

**테스트 대상 코드의 리팩토링 시점**
테스트 대상 코드에서 상수를 변수로 바꾸거나 변수 이름을 변경하는 것과 같은 작은 리팩토링은 발견하면 바로 실행한다.  
반면에 메서드 추출과 같이 메서드 구조에 영향을 주는 리팩토링은 큰 틀에서 구현 흐름이 눈에 들어오기 시작한 뒤에 진행한다.  

구현 초기에는 아직 구현의 전반적인 흐름을 모르기 때문에 메서드 추출과 같은 리팩토링을 진행하면 코드 구조를 잘못 잡을 가능성이 있다  
코드 구조가 잘못되면 다음 테스트를 통과시키는 과정에서 코드가 복잡해지고 구현을 더는 진행하지 못하고 막힐 수 있다.  
이런 상황이 오면 구현을 멈추고 메서드 추출 리팩토링을 되돌려야한다.  
리팩토링을 취소해서 코드를 원상 복구한 뒤에 다음 테스트를 진행한다.   
그런 뒤 코드의 의미가 구조가 더 명확해지면 그때 다시 리팩토링한다.  

